const std = @import("std");

pub const HANDLE = *anyopaque;
pub const LPVOID = *anyopaque;
pub const UINT = c_uint;
pub const LONG = c_long;
pub const CHAR = u8;
pub const SHORT = i16;
pub const WCHAR = u16;
pub const WORD = u16;
pub const DWORD = u32;
pub const LPDWORD = *DWORD;
pub const BOOL = c_int;

pub const INFINITE = 0xffffffff;

// zig fmt: off

pub const STD_INPUT_HANDLE:     DWORD  = std.math.maxInt(DWORD) - 10 + 1;
pub const STD_OUTPUT_HANDLE:    DWORD  = std.math.maxInt(DWORD) - 11 + 1;
pub const STD_ERROR_HANDLE:     DWORD  = std.math.maxInt(DWORD) - 12 + 1;
pub const INVALID_HANDLE_VALUE: HANDLE = @ptrFromInt(std.math.maxInt(usize));

// zig fmt: on

/// Retrieves a handle to the specified standard device (standard input,
/// standard output, or standard error).
pub extern "kernel32" fn GetStdHandle(nStdHandle: DWORD) callconv(.winapi) HANDLE;

/// The specified file is a character file, typically an LPT device or a
/// console.
pub const FILE_TYPE_CHAR = 0x0002;

/// The specified file is a disk file.
pub const FILE_TYPE_DISK = 0x0001;

/// The specified file is a socket, a named pipe, or an anonymous pipe.
pub const FILE_TYPE_PIPE = 0x0003;

/// Either the type of the specified file is unknown, or the
/// function failed.
pub const FILE_TYPE_UNKNOWN = 0x0000;

/// Retrieves the file type of the specified file.
pub extern "kernel32" fn GetFileType(hConsoleHandle: HANDLE) callconv(.winapi) DWORD;

/// Characters read by the ReadFile or ReadConsole function are written to the
/// active screen buffer as they are typed into the console. This mode can be
/// used only if the `ENABLE_LINE_INPUT` mode is also enabled.
pub const ENABLE_ECHO_INPUT: DWORD = 0x0004;

/// When enabled, text entered in a console window will be inserted at the
/// current cursor location and all text following that location will not be
/// overwritten. When disabled, all following text will be overwritten.
pub const ENABLE_INSERT_MODE: DWORD = 0x0020;

/// The ReadFile or ReadConsole function returns only when a carriage return
/// character is read. If this mode is disabled, the functions return when one
/// or more characters are available.
pub const ENABLE_LINE_INPUT: DWORD = 0x0002;

/// If the mouse pointer is within the borders of the console window and the
/// window has the keyboard focus, mouse events generated by mouse movement and
/// button presses are placed in the input buffer. These events are discarded
/// by ReadFile or ReadConsole, even when this mode is enabled. The
/// ReadConsoleInput function can be used to read `MOUSE_EVENT` input records
/// from the input buffer.
pub const ENABLE_MOUSE_INPUT: DWORD = 0x0010;

/// CTRL+C is processed by the system and is not placed in the input buffer. If
/// the input buffer is being read by ReadFile or ReadConsole, other control
/// keys are processed by the system and are not returned in the ReadFile or
/// ReadConsole buffer. If the `ENABLE_LINE_INPUT` mode is also enabled,
/// backspace, carriage return, and line feed characters are handled by the
/// system.
pub const ENABLE_PROCESSED_INPUT: DWORD = 0x0001;

/// User interactions that change the size of the console screen buffer are
/// reported in the console's input buffer. Information about these events can
/// be read from the input buffer by applications using the ReadConsoleInput
/// function, but not by those using ReadFile or ReadConsole.
pub const ENABLE_WINDOW_INPUT: DWORD = 0x0008;

/// Setting this flag directs the Virtual Terminal processing engine to
/// convert user input received by the console window into Console Virtual
/// Terminal Sequences that can be retrieved by a supporting application
/// through ReadFile or ReadConsole functions.
///
/// The typical usage of this flag is intended in conjunction with
/// `ENABLE_VIRTUAL_TERMINAL_PROCESSING` on the output handle to connect to an
/// application that communicates exclusively via virtual terminal sequences.
pub const ENABLE_VIRTUAL_TERMINAL_INPUT: DWORD = 0x0200;

/// Characters written by the WriteFile or WriteConsole function or echoed by
/// the ReadFile or ReadConsole function are parsed for ASCII control
/// sequences, and the correct action is performed. Backspace, tab, bell,
/// carriage return, and line feed characters are processed. It should be
/// enabled when using control sequences or when
/// `ENABLE_VIRTUAL_TERMINAL_PROCESSING` is set.
pub const ENABLE_PROCESSED_OUTPUT: DWORD = 0x0001;

/// When writing with WriteFile or WriteConsole or echoing with ReadFile or
/// ReadConsole, the cursor moves to the beginning of the next row when it
/// reaches the end of the current row. This causes the rows displayed in the
/// console window to scroll up automatically when the cursor advances beyond
/// the last row in the window. It also causes the contents of the console
/// screen buffer to scroll up (../discarding the top row of the console screen
/// buffer) when the cursor advances beyond the last row in the console screen
/// buffer. If this mode is disabled, the last character in the row is
/// overwritten with any subsequent characters.
pub const ENABLE_WRAP_AT_EOL_OUTPUT: DWORD = 0x0002;

/// When writing with WriteFile or WriteConsole, characters are parsed for
/// VT100 and similar control character sequences that control cursor movement,
/// color/font mode, and other operations that can also be performed via the
/// existing Console APIs. For more information, see Console Virtual Terminal
/// Sequences.
///
/// `Ensure ENABLE_PROCESSED_OUTPUT` is set when using this flag.
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING: DWORD = 0x0004;

/// When writing with WriteFile or WriteConsole, this adds an additional state
/// to end-of-line wrapping that can delay the cursor move and buffer scroll
/// operations.
///
/// The typical usage of this flag is intended in conjunction with setting
/// ENABLE_VIRTUAL_TERMINAL_PROCESSING to better emulate a terminal emulator
/// where writing the final character on the screen (in the bottom right
/// corner) without triggering an immediate scroll is the desired behavior.
pub const DISABLE_NEWLINE_AUTO_RETURN: DWORD = 0x0008;

/// Retrieves the current mode of a console's buffer.
pub extern "kernel32" fn GetConsoleMode(
    hConsoleHandle: HANDLE,
    dwMode: LPDWORD,
) callconv(.winapi) BOOL;

/// Sets the input mode of a console's buffer.
pub extern "kernel32" fn SetConsoleMode(
    hConsoleHandle: HANDLE,
    dwMode: DWORD,
) callconv(.winapi) BOOL;

/// Defines the coordinates of a character cell in a console screen buffer. The
/// origin of the coordinate system (0,0) is at the top, left cell of the
/// buffer.
pub const COORD = extern struct {
    /// The horizontal coordinate or column value. The units depend on the
    /// function call.
    X: SHORT,

    /// The vertical coordinate or row value. The units depend on the function
    /// call.
    Y: SHORT,
};

/// Defines the coordinates of the upper left and lower right corners of a
/// rectangle.
pub const SMALL_RECT = extern struct {
    /// The x-coordinate of the upper left corner of the rectangle.
    Left: SHORT,

    /// The y-coordinate of the upper left corner of the rectangle.
    Top: SHORT,

    /// The x-coordinate of the lower right corner of the rectangle.
    Right: SHORT,

    /// The y-coordinate of the lower right corner of the rectangle.
    Bottom: SHORT,
};

/// Contains information about a console screen buffer.
pub const CONSOLE_SCREEN_BUFFER_INFO = extern struct {
    /// A `COORD` structure that contains the size of the console screen
    /// buffer, in character columns and rows.
    dwSize: COORD,

    /// A `COORD` structure that contains the column and row coordinates of the
    /// cursor in the console screen buffer.
    dwCursorPosition: COORD,

    /// The attributes of the characters written to a screen buffer by the
    /// WriteFile and WriteConsole functions, or echoed to a screen buffer by
    /// the ReadFile and ReadConsole functions.
    wAttributes: WORD,

    /// A `SMALL_RECT` structure that contains the console screen buffer
    /// coordinates of the upper-left and lower-right corners of the display
    /// window.
    srWindow: SMALL_RECT,

    /// A `COORD` structure that contains the maximum size of the console
    /// window, in character columns and rows, given the current screen buffer
    /// size and font and the screen size.
    dwMaximumWindowSize: COORD,
};

pub const PCONSOLE_SCREEN_BUFFER_INFO = *CONSOLE_SCREEN_BUFFER_INFO;

/// Retrieves information about the specified console screen buffer.
pub extern "kernel32" fn GetConsoleScreenBufferInfo(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
) callconv(.winapi) BOOL;

/// The specified object is a mutex object that was not released by the thread
/// that owned the mutex object before the owning thread terminated. Ownership
/// of the mutex object is granted to the calling thread and the mutex state is
/// set to nonsignaled.
///
/// If the mutex was protecting persistent state information, you should check
/// it for consistency
pub const WAIT_ABANDONED = 0x00000080;

/// The state of the specified object is signaled.
pub const WAIT_OBJECT_0 = 0x00000000;

/// The time-out interval elapsed, and the object's state is nonsignaled.
pub const WAIT_TIMEOUT = 0x00000102;

/// The function has failed
pub const WAIT_FAILED = 0xffffffff;

/// Waits until the specified object is in the signaled state or the time-out
/// interval elapses.
pub extern "kernel32" fn WaitForSingleObject(
    hHandle: HANDLE,
    dwMilliseconds: DWORD,
) callconv(.winapi) DWORD;

/// Reads data from the specified file or input/output (I/O) device. Reads
/// occur at the position specified by the file pointer if supported by the
/// device.
pub extern "kernel32" fn ReadFile(
    hFile: HANDLE,
    lpBuffer: LPVOID,
    nNumberOfBytesToRead: DWORD,
    lpNumberOfBytesRead: LPDWORD,
    lpOverlapped: ?*anyopaque,
) callconv(.winapi) BOOL;

/// Reads character input from the console input buffer and removes it from the
/// buffer.
pub extern "kernel32" fn ReadConsoleW(
    hConsoleInput: HANDLE,
    lpBuffer: LPVOID,
    nNumberOfCharsToRead: DWORD,
    lpNumberOfCharsRead: LPDWORD,
    pInputControl: ?*anyopaque,
) callconv(.winapi) BOOL;

/// Describes an input event in the console input buffer.
pub const INPUT_RECORD = extern struct {
    /// A handle to the type of input event and the event record stored in the
    /// Event member.
    EventType: WORD,

    /// The event information. The format of this member depends on the event
    /// type specified by the EventType member.
    Event: extern union {
        // zig fmt: off
        KeyEvent:              KEY_EVENT_RECORD,
        MouseEvent:            MOUSE_EVENT_RECORD,
        WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD,
        MenuEvent:             MENU_EVENT_RECORD,
        FocusEvent:            FOCUS_EVENT_RECORD,
        // zig fmt: on
    },
};

pub const PINPUT_RECORD = *INPUT_RECORD;

/// The Event member contains a `FOCUS_EVENT_RECORD` structure. These events
/// are used internally and should be ignored.
pub const FOCUS_EVENT = 0x0010;

/// The Event member contains a `KEY_EVENT_RECORD` structure with information
/// about a keyboard event.
pub const KEY_EVENT = 0x0001;

/// The Event member contains a `MENU_EVENT_RECORD` structure. These events are
/// used internally and should be ignored.
pub const MENU_EVENT = 0x0008;

/// The Event member contains a `MOUSE_EVENT_RECORD` structure with information
/// about a mouse movement or button press event.
pub const MOUSE_EVENT = 0x0002;

/// The Event member contains a `WINDOW_BUFFER_SIZE_RECORD` structure with
/// information about the new size of the console screen buffer.
pub const WINDOW_BUFFER_SIZE_EVENT = 0x0004;

/// Describes a keyboard input event in a console `INPUT_RECORD` structure.
pub const KEY_EVENT_RECORD = extern struct {
    /// If the key is pressed, this member is TRUE. Otherwise, this member is
    /// FALSE (the key is released).
    bKeyDown: BOOL,

    /// The repeat count, which indicates that a key is being held down. For
    /// example, when a key is held down, you might get five events with this
    /// member equal to 1, one event with this member equal to 5, or multiple
    /// events with this member greater than or equal to 1.
    wRepeatCount: WORD,

    /// A virtual-key code that identifies the given key in a
    /// device-independent manner.
    wVirtualKeyCode: WORD,

    /// The virtual scan code of the given key that represents the
    /// device-dependent value generated by the keyboard hardware.
    wVirtualScanCode: WORD,

    /// A union of the following members.
    uChar: extern union {
        /// Translated Unicode character.
        UnicodeChar: WCHAR,

        /// Translated ASCII character.
        AsciiChar: CHAR,
    },

    /// The state of the control keys. This member can be one or more of the
    /// following values.
    dwControlKeyState: DWORD,
};

pub const MOUSE_EVENT_RECORD = extern struct {
    /// A `COORD` structure that contains the location of the cursor, in terms
    /// of the console screen buffer's character-cell coordinates
    dwMousePosition: COORD,

    /// The status of the mouse buttons.
    dwButtonState: DWORD,

    /// The state of the control keys.
    dwControlKeyState: DWORD,

    /// The type of mouse event. If this value is zero, it indicates a mouse
    /// button being pressed or released.
    dwEventFlags: DWORD,
};

/// The CAPS LOCK light is on.
pub const CAPSLOCK_ON = 0x0080;

/// The key is enhanced. See [remarks](https://learn.microsoft.com/en-us/windows/console/key-event-record-str#remarks)
pub const ENHANCED_KEY = 0x0100;

/// The left ALT key is pressed.
pub const LEFT_ALT_PRESSED = 0x0002;

/// The left CTRL key is pressed.
pub const LEFT_CTRL_PRESSED = 0x0008;

/// The NUM LOCK light is on.
pub const NUMLOCK_ON = 0x0020;

/// The right ALT key is pressed.
pub const RIGHT_ALT_PRESSED = 0x0001;

/// The right CTRL key is pressed.
pub const RIGHT_CTRL_PRESSED = 0x0004;

/// The SCROLL LOCK light is on.
pub const SCROLLLOCK_ON = 0x0040;

/// The SHIFT key is pressed.
pub const SHIFT_PRESSED = 0x0010;

/// The leftmost mouse button.
pub const FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;

/// The second button from the left.
pub const FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;

/// The third button from the left.
pub const FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;

/// The fourth button from the left.
pub const FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;

/// The rightmost mouse button.
pub const RIGHTMOST_BUTTON_PRESSED = 0x0002;

/// The second click (button press) of a double-click occurred. The first click
/// is returned as a regular button-press event.
pub const DOUBLE_CLICK = 0x0002;

/// The horizontal mouse wheel was moved.
///
/// If the high word of the dwButtonState
/// member contains a positive value, the wheel was rotated to the right.
/// Otherwise, the wheel was rotated to the left.
pub const MOUSE_HWHEELED = 0x0008;

/// A change in mouse position occurred.
pub const MOUSE_MOVED = 0x0001;

/// The vertical mouse wheel was moved.
///
/// If the high word of the dwButtonState member contains a positive value, the
/// wheel was rotated forward, away from the user. Otherwise, the wheel was
/// rotated backward, toward the user.
pub const MOUSE_WHEELED = 0x0004;

pub const WINDOW_BUFFER_SIZE_RECORD = extern struct {
    dwSize: COORD,
};

pub const MENU_EVENT_RECORD = extern struct {
    dwCommandId: UINT,
};

pub const FOCUS_EVENT_RECORD = extern struct {
    bSetFocus: BOOL,
};

/// Reads data from a console input buffer and removes it from the buffer.
pub extern "kernel32" fn ReadConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: DWORD,
    lpNumberOfEventsRead: LPDWORD,
) callconv(.winapi) BOOL;

/// Reads data from the specified console input buffer without removing it from
/// the buffer.
pub extern "kernel32" fn PeekConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: DWORD,
    lpNumberOfEventsRead: LPDWORD,
) callconv(.winapi) BOOL;

/// Writes a character string to a console screen buffer beginning at the
/// current cursor location.
pub extern "kernel32" fn WriteConsoleW(
    hConsoleOutput: HANDLE,
    lpBuffer: [*]const u16,
    nNumberOfCharsToWrite: DWORD,
    lpNumberOfCharsWritter: LPDWORD,
    lpReserved: ?*anyopaque,
) callconv(.winapi) BOOL;
